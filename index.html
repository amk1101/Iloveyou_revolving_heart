<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>“i love you …” — drag to spin, custom name</title>

<!-- High-readability cursive -->
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@700&display=swap" rel="stylesheet">

<style>
  :root{
    --bg1:#07070a;
    --bg2:#0d0f15;
    --pink:#ff4d88;   /* bright pink */
    --maroon:#a0133b; /* deep maroon */
    --text:#ffe6ef;   /* soft light pink */
  }
  html,body{height:100%;margin:0;background:radial-gradient(1200px 900px at 70% 20%, var(--bg2), var(--bg1));color:#fff;}
  body{font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial;}
  #app{position:fixed; inset:0; overflow:hidden; touch-action:none;} /* drag on phones */
  canvas{display:block;}

  /* Small UI to enter the name */
  #ui{
    position: fixed; top: 12px; left: 50%; transform: translateX(-50%);
    display: flex; gap: 8px; align-items: center;
    background: rgba(255,255,255,.06); border: 1px solid rgba(255,255,255,.14);
    padding: 8px 10px; border-radius: 12px; backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
    z-index: 10;
  }
  #ui input{
    width: 170px; max-width: 56vw;
    background: rgba(255,255,255,.08); border: 1px solid rgba(255,255,255,.18);
    border-radius: 10px; color: #fff; padding: 8px 10px; outline: none;
    font-size: 14px;
  }
  #ui button{
    cursor: pointer; color:#fff;
    background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.04));
    border: 1px solid rgba(255,255,255,.18); border-radius: 10px; padding: 8px 10px;
    font-weight: 600;
  }
  #badge{
    position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%);
    font-size: 12px; letter-spacing:.04em; opacity:.65;
    background: rgba(255,255,255,.06); border: 1px solid rgba(255,255,255,.14);
    padding: 6px 12px; border-radius: 999px; backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
    user-select: none; pointer-events: none;
  }
</style>
</head>
<body>
<div id="app" aria-label="Drag to spin view of a large heart outline with revolving 'i love you …' text"></div>

<!-- Name input UI -->
<form id="ui" autocomplete="off">
  <label for="name" style="font-size:12px;opacity:.85">Name:</label>
  <input id="name" name="name" type="text" placeholder="type a name…" maxlength="24" />
  <button type="submit" title="Apply name">Update</button>
</form>

<div id="badge">Drag to spin • slow revolve • custom name • Made by AM KAAMRAN</div>

<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script>
(() => {
  // ---------- Settings ----------
  const BASE_PHRASE = "i love you";   // fixed part; name is appended when provided
  const isMobile = Math.min(window.innerWidth, window.innerHeight) < 768;
  const PIXEL_RATIO_CAP = isMobile ? 1.8 : 2.2;

  // Heart & path
  const HEART_SCALE = isMobile ? 1.55 : 1.8;   // big heart
  const OUTLINE_SAMPLES = 800;

  // Text sprites (slow + readable)
  const LABEL_COUNT   = isMobile ? 48 : 64;
  const SPRITE_PX     = isMobile ? 40 : 44;
  const SPRITE_WORLD  = isMobile ? 0.34 : 0.36;
  const SPEED         = 0.08;        // cycles per second (slow)
  const DEPTH_WAVE    = 0.10;
  const NORMAL_PUSH   = 0.024;

  // Camera spherical (radius, azimuth θ, elevation φ)
  let radius = isMobile ? 4.6 : 5.4;
  let theta  = Math.PI/4;   // default 45°
  let phi    = 0.6;

  // Drag (inverted direction per your last change)
  let dragging = false, lastX=0, lastY=0;
  let vTheta = 0, vPhi = 0;
  const ROTATE_SENS = -0.005;        // negative -> opposite drag direction
  const DAMPING = 0.92;
  const PHI_MIN = 0.1, PHI_MAX = 1.3;

  // Pinch/wheel zoom
  let lastPinchDist = 0;
  const R_MIN = 3.4, R_MAX = 10;

  // Ensure font crisp on first paint
  Promise.all([
    document.fonts.load(`700 ${Math.floor(SPRITE_PX)}px "Dancing Script"`),
    document.fonts.ready
  ]).then(init);

  function init(){
    // ----- Renderer / Scene -----
    const appEl = document.getElementById('app');
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true, powerPreference:'high-performance' });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, PIXEL_RATIO_CAP));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    appEl.appendChild(renderer.domElement);

    const scene = new THREE.Scene();

    // Lights
    scene.add(new THREE.HemisphereLight(0xffffff, 0x223344, 0.65));
    const pinkKey = new THREE.PointLight(0xff4d88, 1.0, 30); pinkKey.position.set(3,2,5); scene.add(pinkKey);

    // Camera
    const camera = new THREE.PerspectiveCamera(isMobile ? 62 : 58, window.innerWidth / window.innerHeight, 0.1, 100);
    setCameraFromSpherical(camera);

    // ----- Stationary heart outline -----
    const outlineCurve = makeHeartCurve(OUTLINE_SAMPLES, HEART_SCALE);
    scene.add(makeLine(outlineCurve, getCss('--maroon'), getCss('--pink')));

    // ----- Text sprites revolving around the outline -----
    let currentPhrase = BASE_PHRASE;       // starts without a name
    let spriteTex = makeTextTexture(currentPhrase, SPRITE_PX);
    const labels = makeMovingLabels(spriteTex, outlineCurve, LABEL_COUNT, SPRITE_WORLD);
    labels.forEach(s => scene.add(s));

    // ----- Background stars -----
    addBackgroundStars(scene, isMobile ? 380 : 680);

    // ----- UI: name input -> update textures on all labels -----
    const form = document.getElementById('ui');
    const nameInput = document.getElementById('name');
    form.addEventListener('submit', (e) => {
      e.preventDefault();
      const name = (nameInput.value || "").trim();
      const phrase = name ? `${BASE_PHRASE} ${name}` : BASE_PHRASE;
      if (phrase === currentPhrase) return;
      currentPhrase = phrase;
      // build a new texture and apply to all labels, rescaling by aspect
      spriteTex.dispose();
      spriteTex = makeTextTexture(currentPhrase, SPRITE_PX);
      const aspect = spriteTex.image.width / spriteTex.image.height;
      for (const sp of labels){
        sp.material.map = spriteTex;
        sp.material.needsUpdate = true;
        sp.scale.set(SPRITE_WORLD * aspect, SPRITE_WORLD, 1);
      }
    });

    // ----- Pointer controls (drag to spin) -----
    renderer.domElement.addEventListener('pointerdown', (e) => {
      dragging = true; lastX = e.clientX; lastY = e.clientY;
      renderer.domElement.setPointerCapture(e.pointerId);
    });
    renderer.domElement.addEventListener('pointermove', (e) => {
      if (!dragging) return;
      const dx = e.clientX - lastX;
      const dy = e.clientY - lastY;
      lastX = e.clientX; lastY = e.clientY;
      vTheta = -dx * ROTATE_SENS;   // inverted direction
      vPhi   = -dy * ROTATE_SENS;
      theta += vTheta;
      phi   = clamp(phi + vPhi, PHI_MIN, PHI_MAX);
      setCameraFromSpherical(camera);
      e.preventDefault();
    }, {passive:false});
    renderer.domElement.addEventListener('pointerup', (e) => {
      dragging = false;
      renderer.domElement.releasePointerCapture(e.pointerId);
    });

    // Wheel zoom (desktop)
    renderer.domElement.addEventListener('wheel', (e) => {
      radius = clamp(radius + (e.deltaY>0 ? 0.3 : -0.3), R_MIN, R_MAX);
      setCameraFromSpherical(camera);
    }, {passive:true});

    // Pinch zoom (mobile)
    renderer.domElement.addEventListener('touchstart', (e) => {
      if (e.touches.length === 2){
        lastPinchDist = dist2(e.touches[0], e.touches[1]);
      }
    }, {passive:true});
    renderer.domElement.addEventListener('touchmove', (e) => {
      if (e.touches.length === 2){
        const d = dist2(e.touches[0], e.touches[1]);
        const delta = Math.sqrt(lastPinchDist) - Math.sqrt(d);
        lastPinchDist = d;
        radius = clamp(radius + delta * 0.01, R_MIN, R_MAX);
        setCameraFromSpherical(camera);
        e.preventDefault();
      }
    }, {passive:false});

    // ----- Animate (heart stays still; text moves slowly) -----
    let t0 = performance.now();
    (function animate(){
      requestAnimationFrame(animate);

      // inertia when not dragging
      if (!dragging){
        vTheta *= DAMPING;
        vPhi   *= DAMPING;
        if (Math.abs(vTheta) > 1e-4 || Math.abs(vPhi) > 1e-4){
          theta += vTheta;
          phi   = clamp(phi + vPhi, PHI_MIN, PHI_MAX);
          setCameraFromSpherical(camera);
        }
      }

      const t = (performance.now() - t0) / 1000; // seconds
      const cycle = SPEED * t;

      for (let i=0;i<labels.length;i++){
        const sp = labels[i];
        const u = (sp.userData.u0 + cycle) % 1.0;

        const P = sampleCurve(outlineCurve, u);
        const T = tangentOnCurve(outlineCurve, u).normalize();
        const N = new THREE.Vector3(-T.y, T.x, 0).normalize();

        const z = Math.sin((u + i/labels.length) * Math.PI * 2) * DEPTH_WAVE;
        sp.position.set(P.x + N.x * NORMAL_PUSH, P.y + N.y * NORMAL_PUSH, z);
      }

      renderer.render(scene, camera);
    })();

    // Resize
    window.addEventListener('resize', () => {
      const w = window.innerWidth, h = window.innerHeight;
      renderer.setSize(w, h);
      camera.aspect = w/h; camera.updateProjectionMatrix();
    });
  }

  // ---------- Camera helpers ----------
  function setCameraFromSpherical(cam){
    const x = radius * Math.cos(phi) * Math.cos(theta);
    const z = radius * Math.cos(phi) * Math.sin(theta);
    const y = radius * Math.sin(phi);
    cam.position.set(x, y, z);
    cam.lookAt(0,0,0);
  }

  // ---------- Heart curve & sampling ----------
  function heart2D(t){
    const x = 16 * Math.sin(t)**3;
    const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
    return new THREE.Vector2(x, y);
  }
  function makeHeartCurve(samples, scale){
    const pts = [];
    for(let i=0;i<samples;i++){
      const t = (i / samples) * Math.PI * 2;
      pts.push(heart2D(t));
    }
    const box = new THREE.Box2();
    pts.forEach(p => box.expandByPoint(p));
    const c = box.getCenter(new THREE.Vector2());
    const size = box.getSize(new THREE.Vector2());
    const s = (2.0 / Math.max(size.x, size.y)) * scale;
    return pts.map(p => new THREE.Vector3( (p.x - c.x) * s, (p.y - c.y) * s, 0 ));
  }

  function makeLine(curvePts, colorHex, glowHex){
    const geo = new THREE.BufferGeometry().setFromPoints(curvePts.concat([curvePts[0]]));
    const mat = new THREE.LineBasicMaterial({ color: new THREE.Color(colorHex) });
    const line = new THREE.Line(geo, mat);

    // Subtle glow points along the line for phone readability
    const glowGeo = new THREE.BufferGeometry();
    const glowPos = new Float32Array(curvePts.length * 3);
    for (let i=0;i<curvePts.length;i++){
      glowPos[i*3+0] = curvePts[i].x;
      glowPos[i*3+1] = curvePts[i].y;
      glowPos[i*3+2] = 0;
    }
    glowGeo.setAttribute('position', new THREE.BufferAttribute(glowPos, 3));
    const glowMat = new THREE.PointsMaterial({ color: new THREE.Color(glowHex), size: 0.022, transparent:true, opacity:0.33 });
    const glow = new THREE.Points(glowGeo, glowMat);

    const group = new THREE.Group();
    group.add(line);
    group.add(glow);
    return group;
  }

  function lengthTable(curvePts){
    const L = [0];
    for (let i=1;i<curvePts.length;i++){
      L[i] = L[i-1] + curvePts[i].distanceTo(curvePts[i-1]);
    }
    const total = L[curvePts.length-1] + curvePts[curvePts.length-1].distanceTo(curvePts[0]);
    return { L, total };
  }

  const _cache = { curve:null, table:null };
  function ensureTable(curvePts){
    if (_cache.curve !== curvePts){
      _cache.curve = curvePts;
      _cache.table = lengthTable(curvePts);
    }
    return _cache.table;
  }

  function sampleCurve(curvePts, u){
    const { L, total } = ensureTable(curvePts);
    const target = u * total;

    let i=0;
    while (i<L.length && L[i] < target) i++;
    const i0 = (i===0) ? 0 : i-1;
    const p0 = curvePts[i0];
    const p1 = (i>=curvePts.length) ? curvePts[0] : curvePts[i];
    const l0 = (i0===0) ? 0 : L[i0];
    const segLen = p1.distanceTo(p0) || 1e-6;
    const t = (target - l0) / segLen;
    return new THREE.Vector3().lerpVectors(p0, p1, t);
  }

  function tangentOnCurve(curvePts, u){
    const du = 1/curvePts.length;
    const pA = sampleCurve(curvePts, (u - du + 1) % 1);
    const pB = sampleCurve(curvePts, (u + du) % 1);
    return new THREE.Vector3().subVectors(pB, pA);
  }

  // ---------- Text sprites ----------
  function makeTextTexture(phrase, px){
    const pad = Math.max(12, Math.floor(px * 0.6));

    const tmp = document.createElement('canvas').getContext('2d');
    tmp.font = `700 ${px}px "Dancing Script", cursive`;
    const w = Math.ceil(tmp.measureText(phrase).width) + pad*2;
    const h = Math.ceil(px*1.45) + pad*2;

    const W = nextPow2(w), H = nextPow2(h);
    const canvas = document.createElement('canvas'); canvas.width = W; canvas.height = H;
    const ctx = canvas.getContext('2d');

    ctx.clearRect(0,0,W,H);
    ctx.textBaseline = 'middle';
    ctx.textAlign = 'center';
    ctx.font = `700 ${px}px "Dancing Script", cursive`;

    const cx = W/2, cy = H/2;

    // Outer glow for readability
    ctx.shadowColor = getCss('--pink');
    ctx.shadowBlur = Math.max(10, Math.floor(px*0.5));
    ctx.fillStyle = getCss('--text');
    ctx.fillText(phrase, cx, cy);

    // Maroon stroke + fill for crisp edges
    ctx.shadowBlur = 0;
    ctx.lineJoin = 'round';
    ctx.strokeStyle = getCss('--maroon');
    ctx.lineWidth = Math.max(2, Math.floor(px*0.10));
    ctx.strokeText(phrase, cx, cy);
    ctx.fillStyle = getCss('--text');
    ctx.fillText(phrase, cx, cy);

    const tex = new THREE.CanvasTexture(canvas);
    tex.anisotropy = 8;
    tex.colorSpace = THREE.SRGBColorSpace;
    return tex;
  }

  function makeMovingLabels(texture, curvePts, count, worldScale){
    const labels = [];
    const aspect = texture.image.width / texture.image.height;
    for (let i=0;i<count;i++){
      const mat = new THREE.SpriteMaterial({ map: texture, transparent:true, depthTest:true, depthWrite:false });
      const sp = new THREE.Sprite(mat);
      sp.scale.set(worldScale * aspect, worldScale, 1);
      sp.userData.u0 = i / count;
      labels.push(sp);
    }
    return labels;
  }

  // ---------- Stars ----------
  function addBackgroundStars(scene, count){
    const pos = new Float32Array(count*3);
    for(let i=0;i<count;i++){
      const r = 10 + Math.random()*18;
      const th = Math.random()*Math.PI*2;
      const ph = Math.acos(2*Math.random()-1);
      pos[i*3+0] = r*Math.sin(ph)*Math.cos(th);
      pos[i*3+1] = r*Math.sin(ph)*Math.sin(th);
      pos[i*3+2] = r*Math.cos(ph);
    }
    const geo = new THREE.BufferGeometry(); geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
    const mat = new THREE.PointsMaterial({ size: 0.02, color: 0xffffff, transparent:true, opacity:0.28 });
    scene.add(new THREE.Points(geo, mat));
  }

  // ---------- Utils ----------
  function nextPow2(v){ let p=1; while(p<v) p<<=1; return p; }
  function getCss(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }
  function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
  function dist2(t1, t2){ const dx=t1.clientX-t2.clientX, dy=t1.clientY-t2.clientY; return dx*dx+dy*dy; }
})();
</script>
</body>
</html>
