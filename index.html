<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>“i love you …”</title>

<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@700&display=swap" rel="stylesheet">

<style>
  :root{
    --bg1:#07070a;
    --bg2:#0d0f15;

    /* theme vars (updated by JS) */
    --glow:#ff4d88;
    --stroke:#a0133b;
    --text:#ffe6ef;

    /* ui chrome */
    --ui-bg: rgba(10,10,14,.45);
    --ui-bd: rgba(255,255,255,.14);
    --ui-bg-2: rgba(255,255,255,.06);
    --ui-bd-2: rgba(255,255,255,.18);
    --ring: 0 0 0 3px rgba(255,77,136,.28);
  }

  html,body{height:100%;margin:0;background:radial-gradient(1200px 900px at 70% 20%, var(--bg2), var(--bg1));color:#fff;overflow:hidden;}
  body{font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial;}

  /* ---------- Topbar ---------- */
  .topbar{
    position: fixed; left: 50%; top: 10px; transform: translateX(-50%);
    display:flex; flex-direction:column; gap:8px; align-items:center; z-index:10; pointer-events:none;
    max-width: min(92vw, 860px);
  }
  .row{
    display:flex; gap:10px; align-items:center; pointer-events:auto; flex-wrap:wrap;
  }

  .field, .picker, .colorpicker{
    display:flex; align-items:center; gap:8px;
    padding:8px 12px; border-radius:999px;
    background: var(--ui-bg); border:1px solid var(--ui-bd);
    backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
    position:relative;
    transition: box-shadow .15s ease, border-color .15s ease, background .2s ease;
  }
  .field:focus-within, .picker:focus-within, .colorpicker:focus-within{
    box-shadow: var(--ring);
    border-color: var(--glow);
  }

  .topbar input{
    width: clamp(260px, 50vw, 560px);
    height: 38px; padding:0 14px; border-radius:999px;
    border:1px solid var(--ui-bd-2);
    background: rgba(255,255,255,.04); color:#fff; outline:none; font-size:16px;
    transition: border-color .15s ease, background .2s ease;
  }
  .topbar input:focus{ border-color: var(--glow); background: rgba(255,255,255,.06); }

  .topbar button{
    height:38px; min-width:38px; display:grid; place-items:center;
    border-radius:999px; border:1px solid var(--ui-bd-2);
    background: rgba(255,255,255,.08); color:#fff; cursor:pointer;
    transition: transform .06s ease, background .15s ease, border-color .15s ease;
  }
  .topbar button:hover{ background: rgba(255,255,255,.12); }
  .topbar button:active{ transform: translateY(1px) scale(.98); }

  /* --------- Pretty selects (native select, custom shell) --------- */
  .select-wrap{
    position:relative; display:flex; align-items:center;
  }
  .select{
    appearance:none; -webkit-appearance:none; -moz-appearance:none;
    height:38px; padding:0 40px 0 14px; border-radius:999px;
    border:1px solid var(--ui-bd-2);
    background: var(--ui-bg-2);
    color:#fff; font-size:14px; cursor:pointer; outline:none;
    transition: border-color .15s ease, background .2s ease;
  }
  .select:focus{ border-color: var(--glow); background: rgba(255,255,255,.08); }

  /* chevron */
  .chev{
    pointer-events:none; position:absolute; right:10px; width:18px; height:18px; opacity:.9;
    filter: drop-shadow(0 1px 2px rgba(0,0,0,.35));
  }

  /* color swatch circle */
  .swatch{
    width:14px; height:14px; border-radius:50%;
    border:1px solid rgba(255,255,255,.35);
    box-shadow: 0 0 0 3px rgba(255,255,255,.06), 0 0 14px rgba(0,0,0,.35) inset;
  }

  .icon{width:18px;height:18px;display:block}

  /* Helper text */
  .hint{
    font-size:16px; line-height:1.35; opacity:.95; text-align:center; pointer-events:none;
    max-width: min(92vw, 860px);
    margin-top:2px;
  }

  #app{position:fixed; inset:0; touch-action:none;}
  canvas{display:block;}

  /* ---------- Footer ---------- */
  .footer{
    position: fixed; left:50%; transform: translateX(-50%);
    bottom: 10px; display:flex; align-items:center; gap:12px; z-index:10; pointer-events:none; flex-direction:column;
    max-width:min(92vw, 860px);
  }
  .sharelabel{
    font-size:16px; line-height:1.35; opacity:.95; text-align:center; pointer-events:none;
    max-width:min(92vw, 860px);
  }
  .footrow{ display:flex; gap:10px; align-items:center; pointer-events:auto; flex-wrap:wrap; justify-content:center; }

  .pill{
    display:flex; align-items:center; gap:8px; pointer-events:auto;
    padding:8px 12px; border-radius:999px;
    background: var(--ui-bg); border:1px solid var(--ui-bd);
    backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
  }
  .sharebtn{
    display:flex; align-items:center; gap:6px; cursor:pointer;
    border-radius:999px; border:1px solid var(--ui-bd-2);
    background: rgba(255,255,255,.08); padding:8px 12px; color:#fff;
    transition: background .15s ease, border-color .15s ease;
  }
  .sharebtn:hover{ background: rgba(255,255,255,.12); }
  .credit{font-size:11px; opacity:.9}
  .credit a{color:#fff; text-decoration:none}
  .gh{width:16px;height:16px; display:inline-block; vertical-align:-3px; opacity:.95}

  /* ---------- Share sheet ---------- */
  .sheet{
    position: fixed; left:0; right:0; bottom:-220px; z-index:20;
    background: rgba(8,8,12,.86); border-top:1px solid var(--ui-bd);
    box-shadow: 0 -10px 32px rgba(0,0,0,.35);
    transition: bottom .25s ease; padding: 12px;
    backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
  }
  .sheet.open{ bottom:0; }
  .sheet .row{ display:flex; align-items:center; gap:8px; }
  .sheet .link{
    flex:1; min-width:0; font-size:12px; color:#eaeaea;
    padding:8px 10px; border-radius:10px; border:1px solid var(--ui-bd-2);
    background: rgba(255,255,255,.04); white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
  }
  .sheet .btn{
    display:flex; align-items:center; gap:6px; cursor:pointer;
    padding:8px 10px; border-radius:10px; border:1px solid var(--ui-bd-2); background: rgba(255,255,255,.08); color:#fff;
  }
  .sheet .topline{ display:flex; justify-content:space-between; align-items:center; margin-bottom:10px; }
  .sheet .close{ border:none; background:transparent; color:#fff; width:30px; height:30px; border-radius:999px; display:grid; place-items:center; }
  #howto{ margin-top:10px; font-size:12px; opacity:.9 }

  form[name="share-telemetry"]{display:none;}
</style>
</head>
<body>
  <!-- Controls -->
  <div class="topbar" role="region" aria-label="Controls">
    <div class="row">
      <div class="field">
        <input id="textInput" type="text" placeholder="Type text…" autocomplete="off" />
        <button id="applyBtn" title="Apply">
          <svg class="icon" viewBox="0 0 24 24"><path fill="currentColor" d="M9 16.2 4.8 12l-1.4 1.4L9 19 21 7l-1.4-1.4z"/></svg>
        </button>
      </div>

      <!-- Shape picker -->
      <div class="picker">
        <div aria-hidden="true" title="Outline">
          <svg class="icon" viewBox="0 0 24 24"><path fill="currentColor" d="M12 21.3l-1.1-1C6.1 15.9 3 13.1 3 9.7 3 7.1 5.1 5 7.7 5c1.5 0 3 .7 3.9 1.9C12.3 5.7 13.8 5 15.3 5 17.9 5 20 7.1 20 9.7c0 3.4-3.1 6.2-7.9 10.6l-1.1 1z"/></svg>
        </div>
        <div class="select-wrap">
          <select id="shapeSelect" class="select" title="Choose outline">
            <option value="heart">Heart</option>
            <option value="star">Star (soft 5-point)</option>
            <option value="infinity">Infinity</option>
          </select>
          <svg class="chev" viewBox="0 0 24 24"><path fill="currentColor" d="M7 10l5 5 5-5z"/></svg>
        </div>
      </div>

      <!-- Color picker with live swatch -->
      <div class="colorpicker">
        <div class="swatch" id="swatch" aria-hidden="true"></div>
        <div class="select-wrap">
          <select id="colorSelect" class="select" title="Choose color">
            <option value="pink">Pink</option>
            <option value="blue">Blue</option>
            <option value="yellow">Yellow</option>
            <option value="green">Green</option>
            <option value="purple">Purple</option>
          </select>
          <svg class="chev" viewBox="0 0 24 24"><path fill="currentColor" d="M7 10l5 5 5-5z"/></svg>
        </div>
      </div>
    </div>
    <div class="hint">enter text here to show</div>
  </div>

  <!-- Scene -->
  <div id="app" aria-label="Outline animation"></div>

  <!-- Footer -->
  <div class="footer">
    <div class="sharelabel">share with your friends</div>
    <div class="footrow">
      <button id="shareBtn" class="pill sharebtn" title="Share link">
        <svg class="icon" viewBox="0 0 24 24"><path fill="currentColor" d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.02-4.11A2.99 2.99 0 0 0 18 7.91a3 3 0 1 0-2.83-4H15a3 3 0 0 0 0 4.18l-7.02 4.11A3 3 0 1 0 9 12c0-.24-.04-.47-.09-.7l7.13 4.19c.54.5 1.25.81 2.05.81a3 3 0 1 0 0-6z"/></svg>
        Share
      </button>
      <div class="pill credit" title="Creator">
        created by amkaamran
        <a href="https://github.com/amk1101" target="_blank" rel="noopener" aria-label="GitHub">
          <svg class="gh" viewBox="0 0 24 24" aria-hidden="true">
            <path fill="currentColor" d="M12 .5a12 12 0 0 0-3.79 23.4c.6.1.82-.26.82-.58v-2.17c-3.34.73-4.04-1.6-4.04-1.6-.55-1.4-1.35-1.78-1.35-1.78-1.1-.75.08-.73.08-.73 1.22.09 1.87 1.25 1.87 1.25 1.08 1.85 2.83 1.31 3.52 1 .11-.78.42-1.31.77-1.61-2.67-.3-5.47-1.34-5.47-5.95 0-1.31.47-2.39 1.24-3.23-.12-.3-.54-1.52.12-3.17 0 0 1.01-.32 3.3 1.23a11.5 11.5 0 0 1 6.01 0c2.28-1.55 3.29-1.23 3.29-1.23.67 1.65.25 2.87.12 3.17.77.84 1.24 1.92 1.24 3.23 0 4.62-2.81 5.64-5.49 5.94.43.38.82 1.12.82 2.26v3.35c0 .32.22.7.82.58A12 12 0 0 0 12 .5z"/>
          </svg>
        </a>
      </div>
    </div>
  </div>

  <!-- Share sheet -->
  <div id="sheet" class="sheet" role="dialog" aria-label="Share link">
    <div class="topline">
      <span></span>
      <button id="closeSheet" class="close" title="Close">
        <svg class="icon" viewBox="0 0 24 24"><path fill="currentColor" d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
      </button>
    </div>
    <div class="row">
      <div id="shareLink" class="link"></div>
      <button id="copyBtn" class="btn" title="Copy link">
        <svg class="icon" viewBox="0 0 24 24"><path fill="currentColor" d="M16 1H4c-1.1 0-2 .9-2 2v12h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg>
        Copy
      </button>
    </div>
    <div id="howto">How to share: type text → Apply → Share → Copy and send.</div>
  </div>

  <!-- Netlify Forms sink -->
  <form name="share-telemetry" netlify netlify-honeypot="bot-field">
    <input type="text" name="form-name" value="share-telemetry" />
    <input type="text" name="bot-field" />
    <input type="text" name="event" />
    <input type="text" name="apply_seq" />
    <input type="text" name="path_before" />
    <input type="text" name="landing_url" />
    <input type="text" name="name" />
    <input type="text" name="shape" />
    <input type="text" name="color" />
    <input type="text" name="ref" />
    <input type="text" name="utm_source" />
    <input type="text" name="utm_medium" />
    <input type="text" name="utm_campaign" />
    <input type="text" name="ua" />
    <input type="text" name="platform" />
    <input type="text" name="language" />
    <input type="text" name="dpr" />
    <input type="text" name="screen" />
    <input type="text" name="tz" />
    <input type="text" name="width" />
    <input type="text" name="height" />
    <input type="text" name="ts" />
    <input type="text" name="path" />
    <input type="text" name="referrer" />
  </form>

<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script>
(() => {
  /* -------------------- URL params -------------------- */
  const qs = new URLSearchParams(location.search);
  const ref = (qs.get('ref') || '').trim();
  const utm_source = (qs.get('utm_source') || '').trim();
  const utm_medium = (qs.get('utm_medium') || '').trim();
  const utm_campaign = (qs.get('utm_campaign') || '').trim();
  if (ref) { try { localStorage.setItem('ref', ref); } catch {} }
  const landingHref = location.href;

  /* -------------------- Helpers: env + post + counters -------------------- */
  function collectEnv() {
    const tz = Intl.DateTimeFormat().resolvedOptions().timeZone || '';
    return {
      ua: navigator.userAgent,
      platform: (navigator.userAgentData && navigator.userAgentData.platform) || navigator.platform || '',
      language: navigator.language || '',
      dpr: String(window.devicePixelRatio || 1),
      screen: `${screen.width}x${screen.height}`,
      tz,
      width: String(window.innerWidth),
      height: String(window.innerHeight),
      ts: new Date().toISOString(),
      path: location.pathname + location.search,
      referrer: document.referrer || ''
    };
  }
  function postToNetlify(payload) {
    const base = {
      'form-name'   : 'share-telemetry',
      ref           : (new URLSearchParams(location.search).get('ref') || localStorage.getItem('ref') || '').trim(),
      utm_source    : (new URLSearchParams(location.search).get('utm_source') || '').trim(),
      utm_medium    : (new URLSearchParams(location.search).get('utm_medium') || '').trim(),
      utm_campaign  : (new URLSearchParams(location.search).get('utm_campaign') || '').trim(),
      ...collectEnv(),
      ...payload
    };
    const body = new URLSearchParams(base).toString();
    fetch('/', { method:'POST', headers:{'Content-Type':'application/x-www-form-urlencoded'}, body }).catch(()=>{});
  }
  function nextApplySeq(){
    const KEY = 'apply_seq_v1';
    let n = 0;
    try { n = parseInt(sessionStorage.getItem(KEY) || '0', 10) || 0; n++; sessionStorage.setItem(KEY, String(n)); } catch {}
    return n;
  }
  function trackApply(text, shape, color){
    postToNetlify({
      event:'apply',
      name:text,                            // legacy
      shape, color,
      apply_seq:String(nextApplySeq()),
      path_before:location.pathname+location.search,
      landing_url:landingHref
    });
  }

  /* -------------------- Theme palettes -------------------- */
  const PALETTES = {
    pink  : { glow:'#ff4d88', stroke:'#a0133b', text:'#ffe6ef' },
    blue  : { glow:'#57a5ff', stroke:'#1e4ea7', text:'#e9f3ff' },
    yellow: { glow:'#ffd54d', stroke:'#b36b00', text:'#fff9e6' },
    green : { glow:'#4dff88', stroke:'#0f8a4a', text:'#eafff2' },
    purple: { glow:'#c26bff', stroke:'#6a22a7', text:'#f3e9ff' }
  };
  function setTheme(colorKey){
    const pal = PALETTES[colorKey] || PALETTES.pink;
    const root = document.documentElement.style;
    root.setProperty('--glow', pal.glow);
    root.setProperty('--stroke', pal.stroke);
    root.setProperty('--text', pal.text);
    // update swatch
    const sw = document.getElementById('swatch');
    if (sw){
      sw.style.background = pal.glow;
      sw.style.boxShadow = `0 0 0 3px rgba(255,255,255,.06), 0 0 14px ${hexToRgba(pal.glow, .55)} inset`;
      sw.style.borderColor = hexToRgba(pal.stroke, .7);
    }
  }
  function hexToRgba(hex, a){
    const n = hex.replace('#','');
    const r = parseInt(n.substring(0,2),16), g = parseInt(n.substring(2,4),16), b = parseInt(n.substring(4,6),16);
    return `rgba(${r},${g},${b},${a})`;
  }

  /* -------------------- App state -------------------- */
  const initialText  = (qs.get('text')  || qs.get('name') || 'i love you …').trim();
  const initialShape = (qs.get('shape') || 'heart').trim().toLowerCase();
  const initialColor = (qs.get('color') || 'pink').trim().toLowerCase();

  let currentText  = initialText;
  let currentShape = ['heart','star','infinity'].includes(initialShape) ? initialShape : 'heart';
  let currentColor = ['pink','blue','yellow','green','purple'].includes(initialColor) ? initialColor : 'pink';

  // UI refs
  const textInput   = document.getElementById('textInput');
  const shapeSelect = document.getElementById('shapeSelect');
  const colorSelect = document.getElementById('colorSelect');
  const applyBtn  = document.getElementById('applyBtn');
  const shareBtn  = document.getElementById('shareBtn');
  const sheet     = document.getElementById('sheet');
  const closeSheet= document.getElementById('closeSheet');
  const shareLinkEl = document.getElementById('shareLink');
  const copyBtn   = document.getElementById('copyBtn');

  // init UI values
  textInput.value = currentText;
  shapeSelect.value = currentShape;
  colorSelect.value = currentColor;
  setTheme(currentColor);

  /* -------------------- THREE scene -------------------- */
  const PIXEL_RATIO_CAP = 2.0;
  const OUTLINE_SAMPLES = 900;

  const SPRITE_PX_BASE = 64;
  const SPRITE_PX = Math.round(SPRITE_PX_BASE * Math.min(window.devicePixelRatio || 1, 2));
  const SPRITE_WORLD  = 0.48;

  const LABEL_COUNT   = 60;
  const SPEED         = 0.085;
  const DEPTH_WAVE    = 0.12;
  const NORMAL_PUSH   = 0.028;

  let radius = 4.9;
  let theta  = Math.PI/4;
  let phi    = 0.6;

  let dragging = false, lastX=0, lastY=0;
  let vTheta = 0, vPhi = 0;
  const ROTATE_SENS = 0.010;
  const DAMPING = 0.92;
  const PHI_MIN = 0.1, PHI_MAX = 1.3;

  let lastPinchDist = 0;
  const R_MIN = 3.4, R_MAX = 10;

  let renderer, scene, camera, outlineCurve, outlineGroup, labels = [], spriteTexture = null;

  Promise.all([
    document.fonts.load(`700 ${Math.floor(SPRITE_PX)}px "Dancing Script"`),
    document.fonts.ready
  ]).then(init);

  function init(){
    const appEl = document.getElementById('app');
    renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true, powerPreference:'high-performance' });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, PIXEL_RATIO_CAP));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    appEl.appendChild(renderer.domElement);

    scene = new THREE.Scene();
    scene.add(new THREE.HemisphereLight(0xffffff, 0x223344, 0.65));
    const pinkKey = new THREE.PointLight(0xff4d88, 1.0, 30); pinkKey.position.set(3,2,5); scene.add(pinkKey);

    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
    setCameraFromSpherical(camera);

    outlineCurve = makeCurve(currentShape, OUTLINE_SAMPLES);
    outlineGroup = makeLine(outlineCurve, getCss('--stroke'), getCss('--glow'));
    scene.add(outlineGroup);

    spriteTexture = makeTextTexture(currentText, SPRITE_PX);
    labels = makeMovingLabels(spriteTexture, outlineCurve, LABEL_COUNT, SPRITE_WORLD);
    labels.forEach(s => scene.add(s));

    addBackgroundStars(scene, 520);

    renderer.domElement.addEventListener('pointerdown', (e) => {
      dragging = true; lastX = e.clientX; lastY = e.clientY;
      renderer.domElement.setPointerCapture(e.pointerId);
    });
    renderer.domElement.addEventListener('pointermove', (e) => {
      if (!dragging) return;
      const dx = e.clientX - lastX;
      const dy = e.clientY - lastY;
      lastX = e.clientX; lastY = e.clientY;
      vTheta = dx * ROTATE_SENS;
      vPhi   = dy * ROTATE_SENS;
      theta += vTheta;
      phi   = clamp(phi + vPhi, PHI_MIN, PHI_MAX);
      setCameraFromSpherical(camera);
      e.preventDefault();
    }, {passive:false});
    renderer.domElement.addEventListener('pointerup', (e) => {
      dragging = false;
      renderer.domElement.releasePointerCapture(e.pointerId);
    });

    renderer.domElement.addEventListener('wheel', (e) => {
      radius = clamp(radius + (e.deltaY>0 ? 0.3 : -0.3), R_MIN, R_MAX);
      setCameraFromSpherical(camera);
    }, {passive:true});
    renderer.domElement.addEventListener('touchstart', (e) => {
      if (e.touches.length === 2){
        lastPinchDist = dist2(e.touches[0], e.touches[1]);
      }
    }, {passive:true});
    renderer.domElement.addEventListener('touchmove', (e) => {
      if (e.touches.length === 2){
        const d = dist2(e.touches[0], e.touches[1]);
        const delta = Math.sqrt(lastPinchDist) - Math.sqrt(d);
        lastPinchDist = d;
        radius = clamp(radius + delta * 0.01, R_MIN, R_MAX);
        setCameraFromSpherical(camera);
        e.preventDefault();
      }
    }, {passive:false});

    let t0 = performance.now();
    (function animate(){
      requestAnimationFrame(animate);

      if (!dragging){
        vTheta *= DAMPING; vPhi *= DAMPING;
        if (Math.abs(vTheta) > 1e-4 || Math.abs(vPhi) > 1e-4){
          theta += vTheta; phi = clamp(phi + vPhi, PHI_MIN, PHI_MAX);
          setCameraFromSpherical(camera);
        }
      }

      const t = (performance.now() - t0) / 1000;
      const cycle = SPEED * t;

      for (let i=0;i<labels.length;i++){
        const sp = labels[i];
        const u = (sp.userData.u0 + cycle) % 1.0;
        const P = sampleCurve(outlineCurve, u);
        const T = tangentOnCurve(outlineCurve, u).normalize();
        const N = new THREE.Vector3(-T.y, T.x, 0).normalize();
        const z = Math.sin((u + i/labels.length) * Math.PI * 2) * DEPTH_WAVE;
        sp.position.set(P.x + N.x * NORMAL_PUSH, P.y + N.y * NORMAL_PUSH, z);
      }

      renderer.render(scene, camera);
    })();

    window.addEventListener('resize', () => {
      const w = window.innerWidth, h = window.innerHeight;
      renderer.setSize(w, h);
      camera.aspect = w/h; camera.updateProjectionMatrix();
    });

    updateShareLink(); // initial
  }

  /* -------------------- Preview updates (no telemetry, no URL) -------------------- */
  shapeSelect.addEventListener('change', () => {
    currentShape = shapeSelect.value;
    if (outlineGroup) { scene.remove(outlineGroup); disposeGroup(outlineGroup); }
    outlineCurve = makeCurve(currentShape, OUTLINE_SAMPLES);
    outlineGroup = makeLine(outlineCurve, getCss('--stroke'), getCss('--glow'));
    scene.add(outlineGroup);
  });

  colorSelect.addEventListener('change', () => {
    currentColor = colorSelect.value;
    setTheme(currentColor);
    const oldTex = spriteTexture;
    spriteTexture = makeTextTexture(currentText, SPRITE_PX);
    for (const sp of labels){
      sp.material.map = spriteTexture;
      sp.material.needsUpdate = true;
      const aspect = spriteTexture.image.width / spriteTexture.image.height;
      sp.scale.set(SPRITE_WORLD * aspect, SPRITE_WORLD, 1);
    }
    if (oldTex) oldTex.dispose();
    updateOutlineColors(outlineGroup, getCss('--stroke'), getCss('--glow'));
  });

  /* -------------------- Apply (ONLY place that triggers telemetry + URL/share update) -------------------- */
  function applyNow(){
    const t = (textInput.value || '').trim();
    if (!t) return;

    currentText = t;

    // telemetry BEFORE URL change
    trackApply(currentText, currentShape, currentColor);

    // refresh text texture
    const oldTex = spriteTexture;
    spriteTexture = makeTextTexture(currentText, SPRITE_PX);
    for (const sp of labels){
      sp.material.map = spriteTexture;
      sp.material.needsUpdate = true;
      const aspect = spriteTexture.image.width / spriteTexture.image.height;
      sp.scale.set(SPRITE_WORLD * aspect, SPRITE_WORLD, 1);
    }
    if (oldTex) oldTex.dispose();

    // update URL (after logging)
    const u = new URL(location.href);
    u.searchParams.set('text', currentText);
    u.searchParams.set('shape', currentShape);
    u.searchParams.set('color', currentColor);
    if (ref) u.searchParams.set('ref', ref);
    if (utm_source)   u.searchParams.set('utm_source', utm_source);
    if (utm_medium)   u.searchParams.set('utm_medium', utm_medium);
    if (utm_campaign) u.searchParams.set('utm_campaign', utm_campaign);
    history.replaceState(null, '', u);

    updateShareLink();
  }

  applyBtn.addEventListener('click', applyNow);
  textInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') applyNow(); });

  /* -------------------- Share sheet -------------------- */
  shareBtn.addEventListener('click', () => { updateShareLink(); sheet.classList.add('open'); });
  closeSheet.addEventListener('click', () => sheet.classList.remove('open'));
  copyBtn.addEventListener('click', async () => {
    const href = shareLinkEl.dataset.href || shareLinkEl.textContent;
    if (!href) return;
    try { await navigator.clipboard.writeText(href); copyBtn.textContent = 'Copied'; setTimeout(()=>copyBtn.textContent='Copy', 900); }
    catch {
      const tmp = document.createElement('textarea'); tmp.value = href; document.body.appendChild(tmp);
      tmp.select(); document.execCommand('copy'); document.body.removeChild(tmp);
      copyBtn.textContent = 'Copied'; setTimeout(()=>copyBtn.textContent='Copy', 900);
    }
  });

  /* -------------------- Helpers -------------------- */
  function updateShareLink(){
    const url = new URL(location.href);
    url.searchParams.set('text', currentText);
    url.searchParams.set('shape', currentShape);
    url.searchParams.set('color', currentColor);
    const s = url.toString();
    shareLinkEl.textContent = s;
    shareLinkEl.dataset.href = s;
  }

  // Camera helpers
  function setCameraFromSpherical(cam){
    const x = radius * Math.cos(phi) * Math.cos(theta);
    const z = radius * Math.cos(phi) * Math.sin(theta);
    const y = radius * Math.sin(phi);
    cam.position.set(x, y, z);
    cam.lookAt(0,0,0);
  }

  /* -------------------- Curve library (heart, soft star, infinity) -------------------- */
  function makeCurve(kind, samples){
    switch(kind){
      case 'heart':    return makeHeartCurve(samples, 1.7);
      case 'star':     return makeSoftStarCurve(samples, 1.65, 5, 0.52, 1.4);
      case 'infinity': return makeInfinity(samples, 1.6);
      default:         return makeHeartCurve(samples, 1.7);
    }
  }
  function heart2D(t){
    const x = 16 * Math.sin(t)**3;
    const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
    return new THREE.Vector2(x, y);
  }
  function makeHeartCurve(samples, scale){
    const pts = [];
    for(let i=0;i<samples;i++){
      const t = (i / samples) * Math.PI * 2;
      pts.push(heart2D(t));
    }
    return normalize2D(pts, scale);
  }
  function makeSoftStarCurve(samples, scale, points=5, innerRatio=0.5, gamma=1.4){
    const pts = [];
    for(let i=0;i<samples;i++){
      const a = (i / samples) * Math.PI * 2;
      const c = (1 + Math.cos(points * a)) * 0.5;
      const s = Math.pow(c, gamma);
      const r = innerRatio + (1 - innerRatio) * s;
      pts.push(new THREE.Vector2(r*Math.cos(a), r*Math.sin(a)));
    }
    return normalize2D(pts, scale);
  }
  function makeInfinity(samples, scale){
    const pts = [];
    const a = 1.0;
    for (let i=0;i<samples;i++){
      const t = ((i / samples) * Math.PI*2) - Math.PI;
      const denom = 1 + Math.sin(t)**2;
      const x = (a * Math.SQRT1_2 * Math.cos(t)) / denom;
      const y = (a * Math.SQRT1_2 * Math.sin(t) * Math.cos(t)) / denom;
      pts.push(new THREE.Vector2(x, y));
    }
    return normalize2D(pts, scale);
  }
  function normalize2D(pts2, scale){
    const box = new THREE.Box2();
    pts2.forEach(p => box.expandByPoint(p));
    const c = box.getCenter(new THREE.Vector2());
    const size = box.getSize(new THREE.Vector2());
    const s = (2.0 / Math.max(size.x, size.y)) * scale;
    return pts2.map(p => new THREE.Vector3( (p.x - c.x) * s, (p.y - c.y) * s, 0 ));
  }

  /* -------------------- Geometry & labels -------------------- */
  function makeLine(curvePts, strokeColorHex, glowColorHex){
    const geo = new THREE.BufferGeometry().setFromPoints(curvePts.concat([curvePts[0]]));
    const mat = new THREE.LineBasicMaterial({ color: new THREE.Color(strokeColorHex) });
    const line = new THREE.Line(geo, mat);

    const glowGeo = new THREE.BufferGeometry();
    const glowPos = new Float32Array(curvePts.length * 3);
    for (let i=0;i<curvePts.length;i++){
      glowPos[i*3+0] = curvePts[i].x;
      glowPos[i*3+1] = curvePts[i].y;
      glowPos[i*3+2] = 0;
    }
    glowGeo.setAttribute('position', new THREE.BufferAttribute(glowPos, 3));
    const glowMat = new THREE.PointsMaterial({ color: new THREE.Color(glowColorHex), size: 0.024, transparent:true, opacity:0.30 });
    const glow = new THREE.Points(glowGeo, glowMat);

    const group = new THREE.Group();
    group.add(line);
    group.add(glow);
    return group;
  }
  function updateOutlineColors(group, strokeHex, glowHex){
    if (group && group.children && group.children[0]?.material) {
      group.children[0].material.color = new THREE.Color(strokeHex);
      group.children[0].material.needsUpdate = true;
    }
    if (group && group.children && group.children[1]?.material) {
      group.children[1].material.color = new THREE.Color(glowHex);
      group.children[1].material.needsUpdate = true;
    }
  }

  function lengthTable(curvePts){
    const L = [0];
    for (let i=1;i<curvePts.length;i++){
      L[i] = L[i-1] + curvePts[i].distanceTo(curvePts[i-1]);
    }
    const total = L[curvePts.length-1] + curvePts[curvePts.length-1].distanceTo(curvePts[0]);
    return { L, total };
  }
  const _cache = { curve:null, table:null };
  function ensureTable(curvePts){
    if (_cache.curve !== curvePts){
      _cache.curve = curvePts;
      _cache.table = lengthTable(curvePts);
    }
    return _cache.table;
  }
  function sampleCurve(curvePts, u){
    const { L, total } = ensureTable(curvePts);
    const target = u * total;
    let i=0;
    while (i<L.length && L[i] < target) i++;
    const i0 = (i===0) ? 0 : i-1;
    const p0 = curvePts[i0];
    const p1 = (i>=curvePts.length) ? curvePts[0] : curvePts[i];
    const l0 = (i0===0) ? 0 : L[i0];
    const segLen = p1.distanceTo(p0) || 1e-6;
    const t = (target - l0) / segLen;
    return new THREE.Vector3().lerpVectors(p0, p1, t);
  }
  function tangentOnCurve(curvePts, u){
    const du = 1/curvePts.length;
    const pA = sampleCurve(curvePts, (u - du + 1) % 1);
    const pB = sampleCurve(curvePts, (u + du) % 1);
    return new THREE.Vector3().subVectors(pB, pA);
  }

  /* -------------------- Text sprites -------------------- */
  function makeTextTexture(text, px){
    const phrase = text;
    const pad = Math.max(14, Math.floor(px * 0.6));
    const tmp = document.createElement('canvas').getContext('2d');
    tmp.font = `700 ${px}px "Dancing Script", cursive`;
    const w = Math.ceil(tmp.measureText(phrase).width) + pad*2;
    const h = Math.ceil(px*1.45) + pad*2;

    const W = nextPow2(w), H = nextPow2(h);
    const canvas = document.createElement('canvas'); canvas.width = W; canvas.height = H;
    const ctx = canvas.getContext('2d');

    ctx.clearRect(0,0,W,H);
    ctx.textBaseline = 'middle';
    ctx.textAlign = 'center';
    ctx.font = `700 ${px}px "Dancing Script", cursive`;

    const cx = W/2, cy = H/2;

    ctx.shadowColor = getCss('--glow');
    ctx.shadowBlur = Math.max(12, Math.floor(px*0.55));
    ctx.fillStyle = getCss('--text');
    ctx.fillText(phrase, cx, cy);

    ctx.shadowBlur = 0;
    ctx.lineJoin = 'round';
    ctx.strokeStyle = getCss('--stroke');
    ctx.lineWidth = Math.max(2, Math.floor(px*0.10));
    ctx.strokeText(phrase, cx, cy);
    ctx.fillStyle = getCss('--text');
    ctx.fillText(phrase, cx, cy);

    const tex = new THREE.CanvasTexture(canvas);
    tex.anisotropy = 8;
    tex.colorSpace = THREE.SRGBColorSpace;
    return tex;
  }

  function makeMovingLabels(texture, curvePts, count, worldScale){
    const labels = [];
    const aspect = texture.image.width / texture.image.height;
    for (let i=0;i<count;i++){
      const mat = new THREE.SpriteMaterial({ map: texture, transparent:true, depthTest:true, depthWrite:false });
      const sp = new THREE.Sprite(mat);
      sp.scale.set(worldScale * aspect, worldScale, 1);
      sp.userData.u0 = i / count;
      labels.push(sp);
    }
    return labels;
  }

  function addBackgroundStars(scene, count){
    const pos = new Float32Array(count*3);
    for(let i=0;i<count;i++){
      const r = 10 + Math.random()*18;
      const th = Math.random()*Math.PI*2;
      const ph = Math.acos(2*Math.random()-1);
      pos[i*3+0] = r*Math.sin(ph)*Math.cos(th);
      pos[i*3+1] = r*Math.sin(ph)*Math.sin(th);
      pos[i*3+2] = r*Math.cos(ph);
    }
    const geo = new THREE.BufferGeometry(); geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
    const mat = new THREE.PointsMaterial({ size: 0.022, color: 0xffffff, transparent:true, opacity:0.28 });
    scene.add(new THREE.Points(geo, mat));
  }

  /* -------------------- Utils -------------------- */
  function nextPow2(v){ let p=1; while(p<v) p<<=1; return p; }
  function getCss(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }
  function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
  function dist2(t1, t2){ const dx=t1.clientX-t2.clientX, dy=t1.clientY-t2.clientY; return dx*dx+dy*dy; }
  function disposeGroup(g){
    g.traverse(o=>{
      if (o.geometry) o.geometry.dispose?.();
      if (o.material){
        if (Array.isArray(o.material)) o.material.forEach(m=>m.dispose?.());
        else o.material.dispose?.();
      }
    });
  }
})();
</script>
</body>
</html>
